use std::{
    path::{Path, PathBuf},
    process::Command,
    sync::Arc,
};

use dashmap::DashMap;
use rmcp::{ErrorData as McpError, handler::server::router::tool::ToolRouter};
use tracing::debug;

use crate::neovim::{NeovimClientTrait, NeovimError};

impl From<NeovimError> for McpError {
    fn from(err: NeovimError) -> Self {
        match err {
            NeovimError::Connection(msg) => McpError::invalid_request(msg, None),
            NeovimError::Lsp { code, message } => {
                McpError::invalid_request(format!("LSP Error: {code}, {message}"), None)
            }
            NeovimError::Api(msg) => McpError::internal_error(msg, None),
        }
    }
}

pub struct NeovimMcpServer {
    pub nvim_clients: Arc<DashMap<String, Box<dyn NeovimClientTrait + Send>>>,
    pub tool_router: ToolRouter<Self>,
    pub socket_path: PathBuf,
}

impl NeovimMcpServer {
    pub fn new(socket_path: PathBuf) -> Self {
        debug!(
            "Creating new NeovimMcpServer instance with socket_path: {}",
            socket_path.display()
        );
        Self {
            nvim_clients: Arc::new(DashMap::new()),
            tool_router: crate::server::tools::build_tool_router(),
            socket_path,
        }
    }

    pub fn router(&self) -> &ToolRouter<Self> {
        &self.tool_router
    }

    /// Generate shorter connection ID with collision detection
    pub fn generate_shorter_connection_id(&self, target: &str) -> String {
        let full_hash = b3sum(target);
        let id_length = 7;

        // Try different starting positions in the hash for 7-char IDs
        for start in 0..=(full_hash.len().saturating_sub(id_length)) {
            let candidate = &full_hash[start..start + id_length];

            if let Some(existing_client) = self.nvim_clients.get(candidate) {
                // Check if the existing connection has the same target
                if let Some(existing_target) = existing_client.target()
                    && existing_target == target
                {
                    // Same target, return existing connection ID (connection replacement)
                    return candidate.to_string();
                }
                // Different target, continue looking for another ID
                continue;
            }

            // No existing connection with this ID, safe to use
            return candidate.to_string();
        }

        // Fallback to full hash if somehow all combinations are taken
        full_hash
    }

    /// Get connection by ID with proper error handling
    pub fn get_connection(
        &'_ self,
        connection_id: &str,
    ) -> Result<dashmap::mapref::one::Ref<'_, String, Box<dyn NeovimClientTrait + Send>>, McpError>
    {
        self.nvim_clients.get(connection_id).ok_or_else(|| {
            McpError::invalid_request(
                format!("No Neovim connection found for ID: {connection_id}"),
                None,
            )
        })
    }
}

/// Generate BLAKE3 hash from input string
fn b3sum(input: &str) -> String {
    blake3::hash(input.as_bytes()).to_hex().to_string()
}

/// Escape path for use in filename by replacing problematic characters
#[allow(dead_code)]
fn escape_path(path: &str) -> String {
    // Remove leading/trailing whitespace and replace '/' with '%'
    path.trim().replace("/", "%")
}

/// Get git root directory
#[allow(dead_code)]
fn get_git_root() -> Option<String> {
    let output = Command::new("git")
        .args(["rev-parse", "--show-toplevel"])
        .output()
        .ok()?;

    if output.status.success() {
        let result = String::from_utf8(output.stdout).ok()?;
        Some(result.trim().to_string())
    } else {
        None
    }
}

/// Find all existing nvim-mcp socket targets in the filesystem
/// Returns a vector of socket paths that match the pattern generated by the Lua plugin
pub fn find_get_all_targets(socket_path: &Path) -> Vec<String> {
    let pattern = format!("{}/nvim-mcp.*.sock", socket_path.display());

    match glob::glob(&pattern) {
        Ok(paths) => paths
            .filter_map(|entry| entry.ok())
            .map(|path| path.to_string_lossy().to_string())
            .collect(),
        Err(_) => Vec::new(),
    }
}
